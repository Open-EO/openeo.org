(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{324:function(e,a,o){e.exports=o.p+"assets/img/processes.9a2105e4.png"},531:function(e,a,o){"use strict";o.r(a);var t=o(4),r=Object(t.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"process-profiles"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#process-profiles"}},[e._v("#")]),e._v(" Process Profiles")]),e._v(" "),a("p",[e._v('The following image provides an overview of the openEO Processes profiles.\nThe minimal profile that allows an openEO implementation to be called "openEO-compliant" is '),a("em",[e._v("L1 Minimal")]),e._v(".")]),e._v(" "),a("figure",[a("img",{attrs:{src:o(324),alt:"The hierarchy of openEO Processes profiles: L1 Minimal -> L2 Recommended (with sub-profiles) -> L2A/B Raster/Vector -> L3 Advanced (with sub-profiles) -> L4 Above and Beyond"}}),e._v(" "),a("figcaption",[e._v("An overview of the openEO Processes profiles.")])]),e._v(" "),a("ul",[a("li",[a("em",[e._v("L1 Minimal")]),e._v(" ensures that the openEO implementation has a minimal set of functionality which allow users to execute basic use-cases.")]),e._v(" "),a("li",[a("em",[e._v("L2 Recommended")]),e._v(" add functionality that we recommend to be available so that users can more effectively make use of the openEO implementation.")]),e._v(" "),a("li",[a("em",[e._v("L3 Advanced")]),e._v(" allows users to execute more advanced use cases.")]),e._v(" "),a("li",[a("em",[e._v("L4 Above and Beyond")]),e._v(" adds very specific and complex requirements for very specific and highly advanced use cases.")])]),e._v(" "),a("p",[e._v("There are various sub-profiles in L2 (e.g., L2-Date) and L3 (e.g., L3-ML) that add a specific set of functionalities centered around specific needs such as date/time manipulation or execution of machine learning workflows.")]),e._v(" "),a("p",[e._v("In the following chapter you can find a list of requirements per profile.")]),e._v(" "),a("h2",{attrs:{id:"requirements-per-profile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#requirements-per-profile"}},[e._v("#")]),e._v(" Requirements per Profile")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("Note")]),e._v(" "),a("p",[e._v('Missing experimental processes should (by default) lead to a "warning", but not lead to a rejection of that level in openEO.')])]),e._v(" "),a("h3",{attrs:{id:"l1-minimal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#l1-minimal"}},[e._v("#")]),e._v(" L1: Minimal")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("absolute")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("add")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("and")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("apply")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("apply_dimension")])]),e._v(" "),a("ul",[a("li",[e._v("All dimensions that your datacubes can include are supported - x and y can usually be excluded")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("arccos")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("arcsin")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("arctan")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_concat")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_create")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_element")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("between")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("ceil")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("clip")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("constant")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("cos")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("divide")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("e")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("eq")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("exp")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("first")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("floor")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("gt")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("gte")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("int")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("last")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("ln")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("load_collection")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("temporal_extent")]),e._v(": All temporal formats are supported (date-time and date)")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("log")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("lt")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("lte")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("max")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("mean")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("median")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("min")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("mod")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("multiply")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("neq")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("not")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("or")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("pi")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("power")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("product")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("quantiles")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("reduce_dimension")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": At least all processes (up to L1) in the category "),a("code",[e._v("reducer")]),e._v(" that accept an array as input and return a single value as output can be used (also in a chain of processes).")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("dimension")]),e._v(": All dimensions that your datacubes can include are supported - x and y are excluded as they are handled with reduce_spatial")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("round")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("save_result")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("sd")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("sgn")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("sin")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("sqrt")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("subtract")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("sum")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("tan")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("variance")])])])]),e._v(" "),a("h3",{attrs:{id:"l2-recommended"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#l2-recommended"}},[e._v("#")]),e._v(" L2: Recommended")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("add_dimension")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("name")]),e._v(": All suitable dimensions are supported")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("aggregate_temporal")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": At least all processes (up to the level of this requirement) in the category "),a("code",[e._v("reducer")]),e._v(" that accept an array as input and return a single value as output can be used (also in a chain of processes).")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": Supports access to labels in the callback")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("dimension")]),e._v(": All suitable dimensions are supported")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("aggregate_temporal_period")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": At least all processes (up to the level of this requirement) in the category "),a("code",[e._v("reducer")]),e._v(" that accept an array as input and return a single value as output can be used (also in a chain of processes).")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": Supports access to labels in the callback")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("dimension")]),e._v(": All suitable dimensions are supported")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("period")]),e._v(": "),a("code",[e._v("enum")]),e._v(" reflects implemention (all values are supported)")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("all")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("any")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("apply_dimension")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("process")]),e._v(": Supports access to labels in the callback")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("arcosh")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("arctan2")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_element")])]),e._v(" "),a("ul",[a("li",[e._v("Supports labeled arrays")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_find")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("arsinh")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("artanh")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("cosh")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("count")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("dimension_labels")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("dimension")]),e._v(": All suitable dimensions are supported")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("drop_dimension")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("name")]),e._v(": All suitable dimensions are supported")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("extrema")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("filter_bbox")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("filter_temporal")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("dimension")]),e._v(": All suitable dimensions are supported")]),e._v(" "),a("li",[e._v("All temporal formats are supported (date-time and date)")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("if")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("inspect")])]),e._v(" (experimental)\n"),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("level")]),e._v(": "),a("code",[e._v("enum")]),e._v(" reflects implemention (all values are supported)")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("is_nan")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("is_nodata")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("is_valid")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("linear_scale_range")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("nan")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("normalized_difference")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("reduce_dimension")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": At least all processes (up to L2) in the category "),a("code",[e._v("reducer")]),e._v(" that accept an array as input and return a single value as output can be used (also in a chain of processes).")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": Supports access to labels in the callback")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("rename_dimension")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("rename_labels")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("dimension")]),e._v(": All dimensions that your datacubes can include are supported - x and y can usually be excluded")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("sinh")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("sort")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("tanh")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("xor")])])])]),e._v(" "),a("h3",{attrs:{id:"l2a-recommended-raster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#l2a-recommended-raster"}},[e._v("#")]),e._v(" L2A: Recommended Raster")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("aggregate_spatial")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": At least all processes (up to the level of this requirement) in the category "),a("code",[e._v("reducer")]),e._v(" that accept an array as input and return a single value as output can be used (also in a chain of processes).")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("apply_kernel")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("border")]),e._v(": "),a("code",[e._v("enum")]),e._v(" reflects implemention (all values are supported)")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("filter_bands")])]),e._v(" "),a("ul",[a("li",[e._v("Supports filtering by band name")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("filter_spatial")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("load_collection")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("bands")]),e._v(": Supports filtering by band name and common name")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("mask")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("mask_polygon")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("resample_spatial")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("method")]),e._v(": "),a("code",[e._v("enum")]),e._v(" reflects implemention (all values are supported)")])])])]),e._v(" "),a("h3",{attrs:{id:"l2b-recommended-vector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#l2b-recommended-vector"}},[e._v("#")]),e._v(" L2B: Recommended Vector")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("filter_vector")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("vector_buffer")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("vector_reproject")])]),e._v(" (experimental)")])]),e._v(" "),a("h3",{attrs:{id:"l2-date-date-time-manipulation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#l2-date-date-time-manipulation"}},[e._v("#")]),e._v(" L2-Date: Date & Time manipulation")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("date_between")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("date_difference")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("date_shift")])]),e._v(" (experimental)")])]),e._v(" "),a("h3",{attrs:{id:"l2-text-text-manipulation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#l2-text-text-manipulation"}},[e._v("#")]),e._v(" L2-Text: Text manipulation")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("text_begins")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("text_concat (text_merge)")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("text_contains")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("text_ends")])])])]),e._v(" "),a("h3",{attrs:{id:"l3-advanced"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#l3-advanced"}},[e._v("#")]),e._v(" L3: Advanced")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("add_dimension")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("type")]),e._v(": "),a("code",[e._v("enum")]),e._v(" reflects implemention (all values are supported)")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("aggregate_spatial")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": Supports access to labels in the callback")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("aggregate_spatial_window")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("aggregate_temporal")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")]),e._v(" "),a("li",[e._v("All temporal formats are supported (date-time, date and time)")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("aggregate_temporal_period")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("apply")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("process")]),e._v(": At least all processes (up to the level of this requirement) in the categories "),a("code",[e._v("comparison")]),e._v(", "),a("code",[e._v("logic")]),e._v(" and "),a("code",[e._v("math")]),e._v(" can be used (also in a chain of processes).")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("apply_dimension")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("process")]),e._v(": At least all processes (up to the level of this requirement) in the categories "),a("code",[e._v("array")]),e._v(", "),a("code",[e._v("comparison")]),e._v(", "),a("code",[e._v("logic")]),e._v(" and "),a("code",[e._v("math")]),e._v(" can be used (also in a chain of processes).")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("apply_neighborhood")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("process")]),e._v(": Supports access to labels in the callback")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("data")]),e._v(": All listed label types supported.")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("size")]),e._v(" / "),a("code",[e._v("overlap")]),e._v(": Units "),a("code",[e._v("m")]),e._v(", "),a("code",[e._v("px")]),e._v(" and "),a("code",[e._v("null")]),e._v(" are supported")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_append")])]),e._v(" "),a("ul",[a("li",[e._v("Supports labeled arrays")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_apply")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("process")]),e._v(": Supports access to labels in the callback")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")]),e._v(" "),a("li",[e._v("Supports labeled arrays")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_concat")])]),e._v(" "),a("ul",[a("li",[e._v("Supports labeled arrays")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_contains")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_create_labeled")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_filter")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")]),e._v(" "),a("li",[e._v("Supports labeled arrays")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_find_label")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_interpolate_linear")])]),e._v(" "),a("ul",[a("li",[e._v("Supports labeled arrays")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_labels")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_modify")])]),e._v(" (experimental)\n"),a("ul",[a("li",[e._v("Supports labeled arrays")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("cloud_detection")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("count")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("create_data_cube (create_raster_cube)")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("cummax")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("cummin")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("cumproduct")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("cumsum")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("filter_bands")])]),e._v(" "),a("ul",[a("li",[e._v("Supports filtering by common name")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("filter_labels")])]),e._v(" (experimental)\n"),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("dimension")]),e._v(": All suitable dimensions are supported")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("flatten_dimensions")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("is_infinite")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("load_collection")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("properties")]),e._v(": Supports querying by queryables defined via the API.")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("load_geojson")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("load_stac (load_result)")])]),e._v(" (experimental)\n"),a("ul",[a("li",[e._v("Supports loading from STAC API - Features.")]),e._v(" "),a("li",[e._v("Supports loading from STAC API - Item Search.")]),e._v(" "),a("li",[e._v("Supports loading from static STAC.")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("temporal_extent")]),e._v(": All temporal formats are supported (date-time and date)")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("bands")]),e._v(": Supports filtering by band name and common name")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("merge_cubes")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("ndvi")])]),e._v(" "),a("ul",[a("li",[e._v("Supports common names as band names")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("order")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("rearrange")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("reduce_dimension")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("reduce_spatial")])]),e._v(" (experimental)\n"),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": At least all processes (up to the level of this requirement) in the category "),a("code",[e._v("reducer")]),e._v(" that accept an array as input and return a single value as output can be used (also in a chain of processes).")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": Supports access to labels in the callback")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("resample_cube_spatial")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("method")]),e._v(": "),a("code",[e._v("enum")]),e._v(" reflects implemention (all values are supported)")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("resample_cube_temporal")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("dimension")]),e._v(": All suitable dimensions are supported")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("resample_spatial")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("align")]),e._v(": "),a("code",[e._v("enum")]),e._v(" reflects implemention (all values are supported)")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("trim_cube")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("unflatten_dimensions")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("vector_to_random_points")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("vector_to_regular_points")])]),e._v(" (experimental)")])]),e._v(" "),a("h3",{attrs:{id:"l3-ml-machine-learning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#l3-ml-machine-learning"}},[e._v("#")]),e._v(" L3-ML: Machine Learning")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("fit_curve")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("fit_regr_random_forest")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("load_ml_model")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("predict_curve")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("save_ml_model")])]),e._v(" (experimental)")])]),e._v(" "),a("h3",{attrs:{id:"l3-udf-user-defined-functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#l3-udf-user-defined-functions"}},[e._v("#")]),e._v(" L3-UDF: User-Defined Functions")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("run_udf")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("context")]),e._v(": is supported and passed to the callback")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("run_udf_externally")])]),e._v(" (experimental)")])]),e._v(" "),a("h3",{attrs:{id:"l3-clim-cimatology"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#l3-clim-cimatology"}},[e._v("#")]),e._v(" L3-Clim: Cimatology")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("anomaly")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("climatological_normal")])])])]),e._v(" "),a("h3",{attrs:{id:"l3-ard-analysis-ready-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#l3-ard-analysis-ready-data"}},[e._v("#")]),e._v(" L3-ARD: Analysis-Ready Data")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("ard_normalized_radar_backscatter")])]),e._v(" (experimental)\n"),a("ul",[a("li",[e._v("has been tested on > 100x100km at 10m resolution (or equivalent)")]),e._v(" "),a("li",[e._v("Custom parameters are provided via the "),a("code",[e._v("options")]),e._v(" parameter")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("ard_surface_reflectance")])]),e._v(" (experimental)\n"),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("atmospheric_correction_method")]),e._v(": "),a("code",[e._v("enum")]),e._v(" reflects implemention (all values are supported)")]),e._v(" "),a("li",[e._v("Parameter "),a("code",[e._v("cloud_detection_method")]),e._v(": "),a("code",[e._v("enum")]),e._v(" reflects implemention (all values are supported)")]),e._v(" "),a("li",[e._v("Custom parameters are provided via the "),a("code",[e._v("atmospheric_correction_options")]),e._v(" and/or "),a("code",[e._v("cloud_detection_options")]),e._v(" parameters")])])])]),e._v(" "),a("h3",{attrs:{id:"l4-above-and-beyond"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#l4-above-and-beyond"}},[e._v("#")]),e._v(" L4: Above and Beyond")]),e._v(" "),a("ul",[a("li",[a("strong",[a("code",[e._v("aggregate_spatial")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": At least all processes (up to the level of this requirement) in the categories "),a("code",[e._v("array")]),e._v(", "),a("code",[e._v("comparison")]),e._v(", "),a("code",[e._v("logic")]),e._v(" and "),a("code",[e._v("math")]),e._v(" can be used (also in a chain of processes).")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("aggregate_temporal")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": At least all processes (up to the level of this requirement) in the categories "),a("code",[e._v("array")]),e._v(", "),a("code",[e._v("comparison")]),e._v(", "),a("code",[e._v("logic")]),e._v(" and "),a("code",[e._v("math")]),e._v(" can be used (also in a chain of processes).")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("aggregate_temporal_period")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": At least all processes (up to the level of this requirement) in the categories "),a("code",[e._v("array")]),e._v(", "),a("code",[e._v("comparison")]),e._v(", "),a("code",[e._v("logic")]),e._v(" and "),a("code",[e._v("math")]),e._v(" can be used (also in a chain of processes).")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("apply_neighborhood")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("process")]),e._v(": At least all processes (up to the level of this requirement) in the categories "),a("code",[e._v("array")]),e._v(", "),a("code",[e._v("comparison")]),e._v(", "),a("code",[e._v("logic")]),e._v(" and "),a("code",[e._v("math")]),e._v(" can be used (also in a chain of processes).")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("apply_polygon (chunk_polygon)")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("array_apply")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("process")]),e._v(": At least all processes (up to the level of this requirement) in the categories "),a("code",[e._v("comparison")]),e._v(", "),a("code",[e._v("logic")]),e._v(" and "),a("code",[e._v("math")]),e._v(" can be used (also in a chain of processes).")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("atmospheric_correction")])]),e._v(" (experimental)\n"),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("method")]),e._v(": "),a("code",[e._v("enum")]),e._v(" reflects implemention (all values are supported)")]),e._v(" "),a("li",[e._v("Custom parameters are provided via the "),a("code",[e._v("options")]),e._v(" parameter")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("filter_bands")])]),e._v(" "),a("ul",[a("li",[e._v("Supports filtering by wavelength")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("filter_bbox")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("extent")]),e._v(": Supports filtering by base/height")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("load_collection")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("spatial_extent")]),e._v(": Supports filtering by base/height")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("load_stac (load_result)")])]),e._v(" (experimental)\n"),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("spatial_extent")]),e._v(": Supports filtering by base/height")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("load_uploaded_files")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("load_url")])]),e._v(" (experimental)")]),e._v(" "),a("li",[a("strong",[a("code",[e._v("reduce_dimension")])]),e._v(" "),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": At least all processes (up to the level of this requirement) in the categories "),a("code",[e._v("array")]),e._v(", "),a("code",[e._v("comparison")]),e._v(", "),a("code",[e._v("logic")]),e._v(" and "),a("code",[e._v("math")]),e._v(" can be used (also in a chain of processes).")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("reduce_spatial")])]),e._v(" (experimental)\n"),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("reducer")]),e._v(": At least all processes (up to the level of this requirement) in the categories "),a("code",[e._v("array")]),e._v(", "),a("code",[e._v("comparison")]),e._v(", "),a("code",[e._v("logic")]),e._v(" and "),a("code",[e._v("math")]),e._v(" can be used (also in a chain of processes).")])])]),e._v(" "),a("li",[a("strong",[a("code",[e._v("sar_backscatter")])]),e._v(" (experimental)\n"),a("ul",[a("li",[e._v("Parameter "),a("code",[e._v("coefficient")]),e._v(": "),a("code",[e._v("enum")]),e._v(" reflects implemention (all values are supported)")]),e._v(" "),a("li",[e._v("Custom parameters are provided via the "),a("code",[e._v("options")]),e._v(" parameter")])])])])])}),[],!1,null,null,null);a.default=r.exports}}]);