(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{240:function(e,t,a){e.exports=a.p+"assets/img/dc_timeseries.c2c7a902.png"},241:function(e,t,a){e.exports=a.p+"assets/img/dc_flat.01dc91de.png"},242:function(e,t,a){e.exports=a.p+"assets/img/dc_filter.bdafa6d0.png"},243:function(e,t,a){e.exports=a.p+"assets/img/dc_apply_unary.b0ea8e7f.png"},244:function(e,t,a){e.exports=a.p+"assets/img/dc_apply_kernel.4013a72c.png"},245:function(e,t,a){e.exports=a.p+"assets/img/dc_apply_ts.50a7011e.png"},246:function(e,t,a){e.exports=a.p+"assets/img/dc_resample_time.60d19f99.png"},247:function(e,t,a){e.exports=a.p+"assets/img/dc_resample_space.9f9b8cd9.png"},248:function(e,t,a){e.exports=a.p+"assets/img/dc_reduce.872f16c2.png"},249:function(e,t,a){e.exports=a.p+"assets/img/dc_aggregate_space.2b117bf1.png"},378:function(e,t,a){"use strict";a.r(t);var s=a(4),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"datacubes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#datacubes"}},[e._v("#")]),e._v(" Datacubes")]),e._v(" "),s("h2",{attrs:{id:"what-are-datacubes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-are-datacubes"}},[e._v("#")]),e._v(" What are Datacubes?")]),e._v(" "),s("p",[e._v("Datacubes are multidimensional arrays with one or more spatial or temporal dimension(s). They are the way in which data is represented in OpenEO. They provide a nice and tidy interface for spatiotemporal data as well as the operations you may want to execute on it. As they are arrays, it might be easiest to look at raster data as an example, even though datacubes can hold vector data as well. Our example data however consists of a 6x7 raster with 4 bands ["),s("code",[e._v("blue")]),e._v(", "),s("code",[e._v("green")]),e._v(", "),s("code",[e._v("red")]),e._v(", "),s("code",[e._v("near-infrared")]),e._v("] and 3 timesteps ["),s("code",[e._v("2020-10-01")]),e._v(", "),s("code",[e._v("2020-10-13")]),e._v(", "),s("code",[e._v("2020-10-25")]),e._v("], displayed here in an orderly, timeseries-like manner:")]),e._v(" "),s("figure",[s("img",{attrs:{src:a(240),alt:"Datacube timeseries"}}),e._v(" "),s("figcaption",[e._v("An examplary datacube with 4 dimensions: x, y, bands and time.")])]),e._v(" "),s("p",[e._v("It is important to understand that datacubes are designed to make things easier for us, and are not literally a cube, meaning that the above plot is just as good a representation as any other. That is why we can switch the dimensions around and display them in whatever way we want, including the view below:")]),e._v(" "),s("figure",[s("img",{attrs:{src:a(241),alt:"Datacube flat representation"}}),e._v(" "),s("figcaption",[e._v("This is the 'raw' data collection that is our example datacube. The grayscale images are colored for understandability, and dimension labels are displayed.")])]),e._v(" "),s("h2",{attrs:{id:"dimensions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dimensions"}},[e._v("#")]),e._v(" Dimensions")]),e._v(" "),s("p",[e._v("A dimension refers to a certain axis of a datacube. Our exemplary raster datacube has the spatial dimensions "),s("code",[e._v("x")]),e._v(" and "),s("code",[e._v("y")]),e._v(", and the temporal dimension "),s("code",[e._v("t")]),e._v(". Furthermore it has a "),s("code",[e._v("bands")]),e._v(" dimension, extending into the realm of "),s("em",[e._v("what kind of information")]),e._v(" is contained in the cube.")]),e._v(" "),s("p",[e._v("The following properties are usually available for dimensions:")]),e._v(" "),s("ul",[s("li",[e._v("name")]),e._v(" "),s("li",[e._v("axis / number")]),e._v(" "),s("li",[e._v("type (spatial/temporal/bands/other)")]),e._v(" "),s("li",[e._v("extents "),s("em",[e._v("or")]),e._v(" nominal dimension labels")]),e._v(" "),s("li",[e._v("reference system / projections")]),e._v(" "),s("li",[e._v("resolution")])]),e._v(" "),s("p",[e._v("Here is an overview of the dimensions contained in our example datacube above:")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("#")]),e._v(" "),s("th",[e._v("dimension name")]),e._v(" "),s("th",[e._v("dimension labels")]),e._v(" "),s("th",[e._v("resolution")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("1")]),e._v(" "),s("td",[s("code",[e._v("x")])]),e._v(" "),s("td",[s("code",[e._v("466380")]),e._v(", "),s("code",[e._v("466580")]),e._v(", "),s("code",[e._v("466780")]),e._v(", "),s("code",[e._v("466980")]),e._v(", "),s("code",[e._v("467180")]),e._v(", "),s("code",[e._v("467380")])]),e._v(" "),s("td",[e._v("10m")])]),e._v(" "),s("tr",[s("td",[e._v("2")]),e._v(" "),s("td",[s("code",[e._v("y")])]),e._v(" "),s("td",[s("code",[e._v("7167130")]),e._v(", "),s("code",[e._v("7166930")]),e._v(", "),s("code",[e._v("7166730")]),e._v(", "),s("code",[e._v("7166530")]),e._v(", "),s("code",[e._v("7166330")]),e._v(", "),s("code",[e._v("7166130")]),e._v(", "),s("code",[e._v("7165930")])]),e._v(" "),s("td",[e._v("10m")])]),e._v(" "),s("tr",[s("td",[e._v("3")]),e._v(" "),s("td",[s("code",[e._v("bands")])]),e._v(" "),s("td",[s("code",[e._v("blue")]),e._v(", "),s("code",[e._v("green")]),e._v(", "),s("code",[e._v("red")]),e._v(", "),s("code",[e._v("nir")])]),e._v(" "),s("td",[e._v("4 bands")])]),e._v(" "),s("tr",[s("td",[e._v("4")]),e._v(" "),s("td",[s("code",[e._v("t")])]),e._v(" "),s("td",[s("code",[e._v("2020-10-01")]),e._v(", "),s("code",[e._v("2020-10-13")]),e._v(", "),s("code",[e._v("2020-10-25")])]),e._v(" "),s("td",[e._v("12 days")])])])]),e._v(" "),s("h3",{attrs:{id:"applying-processes-on-dimensions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#applying-processes-on-dimensions"}},[e._v("#")]),e._v(" Applying Processes on Dimensions")]),e._v(" "),s("p",[e._v('Some processes are typically applied "along a dimension". You can imagine said dimension as an arrow and whatever is happening as a parallel process to that arrow. It simply means: "we focus on '),s("em",[e._v("this")]),e._v(' dimension right now".')]),e._v(" "),s("h3",{attrs:{id:"resolution"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resolution"}},[e._v("#")]),e._v(" Resolution")]),e._v(" "),s("p",[e._v("The resolution of a dimension gives information about what interval lies between observations. This is most obvious with the temporal resolution, where the intervals depict how often observations were made. Spatial resolution gives information about the pixel spacing, meaning how many 'real world meters' are contained in a pixel. For the "),s("code",[e._v("bands")]),e._v(" dimension, the resolution would correspond to the spectral distance between consecutive bands, but this usually varies from band to band.")]),e._v(" "),s("h2",{attrs:{id:"processes-on-datacubes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#processes-on-datacubes"}},[e._v("#")]),e._v(" Processes on Datacubes")]),e._v(" "),s("p",[e._v("In the following part, the basic processes for manipulating datacubes are introduced.")]),e._v(" "),s("h3",{attrs:{id:"filter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#filter"}},[e._v("#")]),e._v(" Filter")]),e._v(" "),s("p",[e._v("When filtering data (e.g. "),s("a",{attrs:{href:"https://processes.openeo.org/#filter_spatial",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("filter_spatial")]),s("OutboundLink")],1),e._v(", "),s("a",{attrs:{href:"https://processes.openeo.org/#filter_temporal",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("filter_temporal")]),s("OutboundLink")],1),e._v(", "),s("a",{attrs:{href:"https://processes.openeo.org/#filter_bands",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("filter_bands")]),s("OutboundLink")],1),e._v("), only the data that satisfies a condition is returned. For example, this condition could be a timestamp or interval, (a set of) coordinates, or specific bands. By applying filtering the datacube becomes smaller, according to the selected data.")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("Simplified")]),e._v(" "),s("p",[s("span",{attrs:{title:"Filtering vegetarian options from [corn, potato, pig] returns [corn, potato].\n"}},[s("code",[e._v("filter([🌽, 🥔, 🐷], isVegetarian) => [🌽, 🥔]")])])])]),e._v(" "),s("p",[e._v("In the image, the example datacube can be seen at the top with labeled dimensions. The filtering techniques are displayed separately below. On the left, the datacube is filtered temporally with the interval "),s("code",[e._v('["2020-10-15", "2020-10-27"]')]),e._v(". The result is a cube with only the rasters for the timestep that lies within that interval ("),s("code",[e._v('"2020-10-25"')]),e._v(") and unchanged bands and spatial dimensions. Likewise, the original cube is filtered for a specific band "),s("code",[e._v('["nir"]')]),e._v(" in the middle and a specific spatial region "),s("code",[e._v("[Polygon(...)]")]),e._v(" on the right.")]),e._v(" "),s("figure",[s("img",{attrs:{src:a(242),alt:"Datacube filtering"}}),e._v(" "),s("figcaption",[e._v("Filtering the sample datacube. It is displayed at the top with dimensions labels. Filtered results are shown at the bottom.")])]),e._v(" "),s("h3",{attrs:{id:"apply"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#apply"}},[e._v("#")]),e._v(" Apply")]),e._v(" "),s("p",[e._v("The "),s("code",[e._v("apply*")]),e._v(" functions (e.g. "),s("a",{attrs:{href:"https://processes.openeo.org/#apply",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("apply")]),s("OutboundLink")],1),e._v(", "),s("a",{attrs:{href:"https://processes.openeo.org/#apply_neighbourhood",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("apply_neighbourhood")]),s("OutboundLink")],1),e._v(", "),s("a",{attrs:{href:"https://processes.openeo.org/#apply_dimension",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("apply_dimension")]),s("OutboundLink")],1),e._v(") employ a process on the datacube that calculates new pixel values for each pixel, based on "),s("code",[e._v("n")]),e._v(" other pixels.")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("Simplified")]),e._v(" "),s("p",[s("span",{attrs:{title:"Applying the process 'cook' to [corn, potato, pig] returns [popcorn, fries, meat]."}},[s("code",[e._v("apply([🌽, 🥔, 🐷], cook) => [🍿, 🍟, 🍖]")])])])]),e._v(" "),s("p",[e._v("For the case "),s("code",[e._v("n = 1")]),e._v(" this is called an unary function and means that only the pixel itself is considered when calculating the new pixel value. A prominent example is the "),s("code",[e._v("absolute()")]),e._v(" function, calculating the absolute value of the input pixel value.")]),e._v(" "),s("figure",[s("img",{attrs:{src:a(243),alt:"Datacube apply unary"}}),e._v(" "),s("figcaption",[e._v("Applying an unary process. Only the pixel itself is considered for calculating the new pixel value.")])]),e._v(" "),s("p",[e._v("If "),s("code",[e._v("n")]),e._v(" is larger than 1, the function is called n-ary. In practice, this means that the pixel neighbourhood is taken into account to calculate the new pixel value. Such neighbourhoods can be of temporal and/or spatial nature. A temporal function works on a time series at a certain pixel location (e.g. smoothing values over time), a spatial function works on a kernel that weights the surrounding pixels (e.g. smoothing values with nearby observations). Combinations of types to n-dimensional neighbourhoods are also possible.")]),e._v(" "),s("p",[e._v("In the example below, an example weighted kernel (shown in the middle) is applied to the cube. To avoid edge effects (affecting pixels on the edge of the image with less neighbours), a padding has been added in the background.")]),e._v(" "),s("figure",[s("img",{attrs:{src:a(244),alt:"Datacube apply spatial kernel"}}),e._v(" "),s("figcaption",[e._v("Applying a spatial kernel. For calculating each new pixel value, the defined weighted neighbourhood is used.")])]),e._v(" "),s("p",[e._v("Of course this also works for temporal neighbourhoods (timeseries), considering neighbours before and after a pixel. To be able to show the effect, two timesteps were added in this example figure. A moving average of window size 3 is then applied. While this process is applied to all pixels in the cube, a specific pixel timeseries is highlighted (green line) and processed step-by-step. No padding was added which is why we observe edge effects (NA values are returned for t"),s("sub",[e._v("1")]),e._v(" and t"),s("sub",[e._v("5")]),e._v(", because their temporal neighbourhood is missing input timesteps).")]),e._v(" "),s("figure",[s("img",{attrs:{src:a(245),alt:"Datacube apply temporal moving average"}}),e._v(" "),s("figcaption",[e._v("Applying a moving average (temporal smoothing) by averaging the direct temporal neighbourhoods of pixels. No padding is used, which leads to edge effects.")])]),e._v(" "),s("p",[e._v("Alternatively, a process can also be applied along a dimension of the datacube, meaning the input is no longer a neighbourhood of some sort but all pixels along that dimension. If a process is applied along the "),s("code",[e._v("time")]),e._v(" dimension (e.g. a breakpoint detection), the complete pixel timeseries are the input. If a process is applied along the "),s("code",[e._v("spatial")]),e._v(" dimensions (e.g. a "),s("code",[e._v("mean")]),e._v("), all pixels of an image are the input. The process is then applied to all pixels along that dimension and the dimension continues to exist. This is in contrast to "),s("a",{attrs:{href:"#reduce"}},[e._v("reduce")]),e._v(", as you will see below.")]),e._v(" "),s("h3",{attrs:{id:"resample"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resample"}},[e._v("#")]),e._v(" Resample")]),e._v(" "),s("p",[e._v("In a resampling processes (e.g. "),s("a",{attrs:{href:"https://processes.openeo.org/#resample_cube_spatial",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("resample_cube_spatial")]),s("OutboundLink")],1),e._v(", "),s("a",{attrs:{href:"https://processes.openeo.org/#resample_cube_temporal",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("resample_cube_temporal")]),s("OutboundLink")],1),e._v("), the "),s("em",[e._v("layout")]),e._v(" of a certain dimension is changed into another "),s("em",[e._v("layout")]),e._v(", most likely also changing the resolution of that dimension. This is done by mapping values of the source (old) datacube to the new layout of the target (new) datacube. During that process, resolutions can be "),s("em",[e._v("upscaled")]),e._v(" or "),s("em",[e._v("downscaled")]),e._v(" (also called "),s("em",[e._v("upsampling")]),e._v(" and "),s("em",[e._v("downsampling")]),e._v("), depending on whether they have a finer or a coarser spacing afterwards. A function is then needed to translate the existing data into the new resolution. A prominent example is to reproject a datacube into the coordinate reference system of another datacube, for example in order to merge the two cubes.")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("Simplified")]),e._v(" "),s("p",[s("span",{attrs:{title:"Downscaling a raster image (to infinity) returns one pixel."}},[s("code",[e._v("resample(🖼️, downscale) => 🟦")])])]),e._v(" "),s("p",[s("span",{attrs:{title:"Reprojecting a globe results into a map."}},[s("code",[e._v("resample(🌍, reproject) => 🗺️")])])])]),e._v(" "),s("p",[e._v("The first figure gives an overview of temporal resampling. How exactly the input timesteps are rescaled to the output timesteps depends on the resampling function.")]),e._v(" "),s("figure",[s("img",{attrs:{src:a(246),alt:"Datacube temporal resampling (up and down)"}}),e._v(" "),s("figcaption",[e._v("Temporal downsampling is seen on the left, upsampling on the right. The temporal layout that the cubes are resampled to is displayed in the middle.")])]),e._v(" "),s("p",[e._v("The second figure displays spatial resampling. Observe how in the upsampling process, the output datacube has not gained in information value. The resulting grid still carries the same pixel information, but in higher spatial resolution. Other upsampling methods may yield smoother results, e.g. by using interpolation.")]),e._v(" "),s("figure",[s("img",{attrs:{src:a(247),alt:"Datacube spatial resampling (up and down)"}}),e._v(" "),s("figcaption",[e._v("Spatial resampling. The geometry which the input cube is resampled to is displayed in the middle. The output cube then contains the same information, but in the resampled spatial layout.")])]),e._v(" "),s("h3",{attrs:{id:"reduce"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reduce"}},[e._v("#")]),e._v(" Reduce")]),e._v(" "),s("p",[e._v("The "),s("a",{attrs:{href:"https://processes.openeo.org/#reduce_dimension",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("reduce_dimension")]),s("OutboundLink")],1),e._v(" process "),s("em",[e._v("collapses")]),e._v(" a whole dimension of the datacube. It does so by using some sort of "),s("strong",[e._v("reducer")]),e._v(", which is a function that calculates a single result from an amount of values, as e.g. "),s("code",[e._v("mean()")]),e._v(", "),s("code",[e._v("min()")]),e._v(" and "),s("code",[e._v("max()")]),e._v(" are. For example we can reduce the time dimension ("),s("code",[e._v("t")]),e._v(") of a timeseries by calculating the mean value of all timesteps for each pixel. We are left with a cube that has no time dimension, because all values of that dimension are compressed into a single mean value. The same goes for e.g. the spatial dimensions: If we calculate the mean along the "),s("code",[e._v("x")]),e._v(" and "),s("code",[e._v("y")]),e._v(" dimensions, we are left without any spatial dimensions, but a mean value for each instance that previously was a raster is returned. In the image below, the dimensions that are reduced are crossed out in the result.")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("Simplified")]),e._v(" "),s("p",[s("span",{attrs:{title:"Reducing [mixed greens, cucumber, tomato, onion] returns a salad."}},[s("code",[e._v("reduce(🥬, 🥒, 🍅, 🧅) => 🥗")])])])]),e._v(" "),s("p",[e._v("Think of it as a waste press that does math instead of using brute force. Given a representation of our example datacube, let's see how it is affected.")]),e._v(" "),s("figure",[s("img",{attrs:{src:a(248),alt:"Datacube reduce"}}),e._v(" "),s("figcaption",[e._v("Overview of reducing the sample datacube. Dimensions that are reduced are crossed out in the result images. Their information value has been compressed by a reducer function.")])]),e._v(" "),s("h3",{attrs:{id:"aggregate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aggregate"}},[e._v("#")]),e._v(" Aggregate")]),e._v(" "),s("p",[e._v("An aggregation of a datacube can be thought of as a grouped reduce. That means it consists of two steps:")]),e._v(" "),s("ol",[s("li",[e._v("Grouping via a grouping variable, i.e. spatial geometries or temporal intervals")]),e._v(" "),s("li",[e._v("Reducing these groups along the grouped dimension with a certain reducer function, e.g. calculating the mean pixel value per polygon or the maximum pixel values per month")])]),e._v(" "),s("p",[e._v("While the layout of the reduced dimension is changed, other dimensions keep their resolution and geometry. But in contrast to pure "),s("code",[e._v("reduce")]),e._v(", the dimension along which the reducer function is applied still exists after the operation.")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("Simplified")]),e._v(" "),s("p",[s("span",{attrs:{title:"Aggregating different family representations with 3, 2 and 4 members with the function 'countFamilyMembers' returns [3, 2, 4]."}},[s("code",[e._v("aggregate(👪 👩‍👦 👨‍👩‍👦‍👦, countFamilyMembers) => [3️⃣, 2️⃣, 4️⃣]")])])])]),e._v(" "),s("p",[e._v("A temporal aggregation (e.g. "),s("a",{attrs:{href:"https://processes.openeo.org/#aggregate_temporal",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("aggregate_temporal")]),s("OutboundLink")],1),e._v(") is similar to the downsampling process, as it can be seen in the according image above. Intervals for grouping can either be set manually, or periods can be chosen: monthly, yearly, etc. All timesteps in an interval are then collapsed via a reducer function ("),s("code",[e._v("mean")]),e._v(", "),s("code",[e._v("max")]),e._v(", etc.) and assigned to the given new labels.")]),e._v(" "),s("p",[e._v("A spatial agregation (e.g. "),s("a",{attrs:{href:"https://processes.openeo.org/#aggregate_spatial",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("aggregate_spatial")]),s("OutboundLink")],1),e._v(") works in a similar manner. Polygons, lines and points can be selected for grouping. Their spatial dimension is then reduced by a given process and thus, a vector cube is returned. The vector cube then has dimensions containing features, attributes and time. In the graphic below, the grouping is only shown for the first timestep.")]),e._v(" "),s("figure",[s("img",{attrs:{src:a(249),alt:"Datacube spatial aggregation"}}),e._v(" "),s("figcaption",[e._v("When aggregating spatially, pixels are grouped (cut out) based on geometries, and then collapsed with a reducer function. A vector datacube is returned (as shown with dimensions names and labels).")])])])}),[],!1,null,null,null);t.default=i.exports}}]);